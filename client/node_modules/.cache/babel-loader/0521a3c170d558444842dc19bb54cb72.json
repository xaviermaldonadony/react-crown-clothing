{"ast":null,"code":"import { FETCH_COLLECTIONS_FAILURE, FETCH_COLLECTIONS_START, FETCH_COLLECTIONS_SUCCESS } from './shop.types';\nimport { firestore, convertCollectionsSnapShotToMap } from '../../firebase/firebase.utils'; // we usually write a function that returns an action/object\n// we are going to write a function that returns a function\n// that gets dispatch in it, when ever dispatch is called it fill fire multiple actions\n\nexport const fetchCollectionsStart = () => ({\n  type: FETCH_COLLECTIONS_START\n});\nexport const fetchCollectionsSuccess = collectionsMap => ({\n  type: FETCH_COLLECTIONS_SUCCESS,\n  payload: collectionsMap\n});\nexport const fetchCollectionsFailure = error => ({\n  type: FETCH_COLLECTIONS_FAILURE,\n  payload: error\n}); // Thunk ex, is just a function that returns a function that gets acces to dispatch\n\nexport const fetchCollectionsStartAsync = () => dispatch => {\n  const collectionRef = firestore.collection('collections'); // dispatches fetchCollectionsStart, which changes our isFetching state to true\n\n  dispatch(fetchCollectionsStart()); // it begins this async request this is why we use redux-thunk\n\n  collectionRef.get().then(snapshot => {\n    const collectionsMap = convertCollectionsSnapShotToMap(snapshot);\n    dispatch(fetchCollectionsSuccess(collectionsMap));\n  }).catch(error => dispatch(fetchCollectionsFailure(error.message)));\n};","map":{"version":3,"sources":["/home/xavi/fullstack/react-crown-clothing/client/src/redux/shop/shop.actions.js"],"names":["FETCH_COLLECTIONS_FAILURE","FETCH_COLLECTIONS_START","FETCH_COLLECTIONS_SUCCESS","firestore","convertCollectionsSnapShotToMap","fetchCollectionsStart","type","fetchCollectionsSuccess","collectionsMap","payload","fetchCollectionsFailure","error","fetchCollectionsStartAsync","dispatch","collectionRef","collection","get","then","snapshot","catch","message"],"mappings":"AAAA,SACCA,yBADD,EAECC,uBAFD,EAGCC,yBAHD,QAIO,cAJP;AAMA,SACCC,SADD,EAECC,+BAFD,QAGO,+BAHP,C,CAKA;AACA;AACA;;AACA,OAAO,MAAMC,qBAAqB,GAAG,OAAO;AAC3CC,EAAAA,IAAI,EAAEL;AADqC,CAAP,CAA9B;AAIP,OAAO,MAAMM,uBAAuB,GAAIC,cAAD,KAAqB;AAC3DF,EAAAA,IAAI,EAAEJ,yBADqD;AAE3DO,EAAAA,OAAO,EAAED;AAFkD,CAArB,CAAhC;AAKP,OAAO,MAAME,uBAAuB,GAAIC,KAAD,KAAY;AAClDL,EAAAA,IAAI,EAAEN,yBAD4C;AAElDS,EAAAA,OAAO,EAAEE;AAFyC,CAAZ,CAAhC,C,CAKP;;AACA,OAAO,MAAMC,0BAA0B,GAAG,MAAOC,QAAD,IAAc;AAC7D,QAAMC,aAAa,GAAGX,SAAS,CAACY,UAAV,CAAqB,aAArB,CAAtB,CAD6D,CAE7D;;AACAF,EAAAA,QAAQ,CAACR,qBAAqB,EAAtB,CAAR,CAH6D,CAK7D;;AACAS,EAAAA,aAAa,CACXE,GADF,GAEEC,IAFF,CAEQC,QAAD,IAAc;AACnB,UAAMV,cAAc,GAAGJ,+BAA+B,CAACc,QAAD,CAAtD;AACAL,IAAAA,QAAQ,CAACN,uBAAuB,CAACC,cAAD,CAAxB,CAAR;AACA,GALF,EAMEW,KANF,CAMSR,KAAD,IAAWE,QAAQ,CAACH,uBAAuB,CAACC,KAAK,CAACS,OAAP,CAAxB,CAN3B;AAOA,CAbM","sourcesContent":["import {\n\tFETCH_COLLECTIONS_FAILURE,\n\tFETCH_COLLECTIONS_START,\n\tFETCH_COLLECTIONS_SUCCESS,\n} from './shop.types';\n\nimport {\n\tfirestore,\n\tconvertCollectionsSnapShotToMap,\n} from '../../firebase/firebase.utils';\n\n// we usually write a function that returns an action/object\n// we are going to write a function that returns a function\n// that gets dispatch in it, when ever dispatch is called it fill fire multiple actions\nexport const fetchCollectionsStart = () => ({\n\ttype: FETCH_COLLECTIONS_START,\n});\n\nexport const fetchCollectionsSuccess = (collectionsMap) => ({\n\ttype: FETCH_COLLECTIONS_SUCCESS,\n\tpayload: collectionsMap,\n});\n\nexport const fetchCollectionsFailure = (error) => ({\n\ttype: FETCH_COLLECTIONS_FAILURE,\n\tpayload: error,\n});\n\n// Thunk ex, is just a function that returns a function that gets acces to dispatch\nexport const fetchCollectionsStartAsync = () => (dispatch) => {\n\tconst collectionRef = firestore.collection('collections');\n\t// dispatches fetchCollectionsStart, which changes our isFetching state to true\n\tdispatch(fetchCollectionsStart());\n\n\t// it begins this async request this is why we use redux-thunk\n\tcollectionRef\n\t\t.get()\n\t\t.then((snapshot) => {\n\t\t\tconst collectionsMap = convertCollectionsSnapShotToMap(snapshot);\n\t\t\tdispatch(fetchCollectionsSuccess(collectionsMap));\n\t\t})\n\t\t.catch((error) => dispatch(fetchCollectionsFailure(error.message)));\n};\n"]},"metadata":{},"sourceType":"module"}